use crate::custom_package::CustomPackageList;
use crate::flatpak_package::FlatpakPackageList;
use crate::prelude::RustPackageList;
use crate::system_package::SystemPackageList;
use crate::utils::get_config;
use crate::APP_NAME;
use color_eyre::Result;
use ctrem::*;
use indexmap::IndexMap;
use serde::{Deserialize, Serialize};
use std::fs::{File, OpenOptions};
use std::io::BufRead;
use std::io::Write;
use std::path::PathBuf;

pub type AliasList = IndexMap<String, String>;

#[derive(Default, Debug, Clone, Eq, PartialEq, Serialize, Deserialize)]
pub struct CommonOptions {
    #[serde(default, skip_serializing_if = "IndexMap::is_empty")]
    pub alias: AliasList,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub documentation: Option<String>,
}

pub trait PackageProvider {
    fn get_source(&self) -> &str;

    fn package_type(&self) -> &str;

    fn get_extras(&self) -> &CommonOptions;

    fn install_args(&self) -> Vec<&str>;

    fn get_aliases(&self) -> &AliasList {
        &self.get_extras().alias
    }

    fn check_if_installed(&self) -> bool {
        false
    }

    fn install(&self, options: &InstallOptions) -> Result<()> {
        if self.check_if_installed() {
            cprintln(&format!(
                "   [blue]-  Skip[/] installing {}: [green]{}[/]",
                self.package_type(),
                self.get_source()
            ));
            return Ok(());
        }
        self.installing_header();

        match crate::utils::run(&self.install_args(), options) {
            Ok(_) => {}
            Err(_err) => {
                cprintln(&format!(
                    "   [red]-  Error[/] installing {}: [green]{}[/]",
                    self.package_type(),
                    self.get_source()
                ));
                if !options.keep_running {
                    std::process::exit(1);
                }
            }
        }
        Ok(())
    }

    fn installing_header(&self) {
        cprintln(&format!(
            "   [green]+[/] Installing [blue]{}[/] package [blue]{}[/]",
            self.package_type(),
            self.get_source()
        ));
        if let Some(description) = &self.get_extras().description {
            println!("     {}", description);
        }
        if let Some(text) = &self.get_extras().repository {
            println!("     - Repository: {}", text);
        }
        if let Some(text) = &self.get_extras().documentation {
            println!("     - Documentation: {}", text);
        }
    }
}

pub trait PackageListProvider {}

#[derive(Default, Debug, Clone, Eq, PartialEq, Serialize, Deserialize)]
pub struct PackageList {
    pub apt: SystemPackageList,
    pub rust: RustPackageList,
    pub flatpak: FlatpakPackageList,
    pub custom: CustomPackageList,
}

#[derive(Debug, Clone)]
pub struct InstallOptions {
    pub verbose: bool,
    pub dry_run: bool,
    pub keep_running: bool,
}

impl Default for InstallOptions {
    fn default() -> Self {
        Self {
            verbose: true,
            dry_run: false,
            keep_running: false,
        }
    }
}

impl PackageList {
    pub fn serialize(&self) -> Result<String> {
        let toml = toml::to_string(&self)?;
        let header = "# Automatically generated by rust-software. Don't edit manually";
        Ok(format!("{}\n\n{}", header, toml))
    }

    pub fn deserialize(input: &str) -> Result<Self> {
        let mut me: Self = toml::from_str(input)?;
        for (name, package) in me.apt.iter_mut() {
            package.source = name.clone();
        }
        for (name, package) in me.rust.iter_mut() {
            package.source = name.clone();
        }
        for (name, package) in me.flatpak.iter_mut() {
            package.source = name.clone();
        }
        for (name, package) in me.custom.iter_mut() {
            package.source = name.clone();
        }
        Ok(me)
    }

    pub fn install(path: &PathBuf, options: &InstallOptions) -> Result<()> {
        cprintln(&format!(
            "[green]+[/] Installing file [bold][blue]{}[//]",
            path.display()
        ));
        let toml_text = std::fs::read_to_string(path)?;
        let toml_text = format!("{}\n[apt]\n[rust]\n[flatpak]\n[custom]", toml_text);
        match Self::deserialize(&toml_text) {
            Ok(list) => list.install_packages(options)?,
            Err(err) => {
                let inner = err.to_string();
                cprintln(&format!(
                    "    [red]-  Error[/] parsing config file: [green]{}[/]",
                    path.display()
                ));
                eprintln!("{}", inner);
                if !options.keep_running {
                    std::process::exit(1);
                }
            }
        }
        Ok(())
    }

    pub fn install_packages(&self, options: &InstallOptions) -> Result<()> {
        let alias_filename = get_config(APP_NAME, "alias.d")?.join("system.sh");
        if !alias_filename.exists() {
            let mut alias_file = File::create(&alias_filename)?;
            writeln!(alias_file, "#!/usr/bin/env bash")?;
            writeln!(
                alias_file,
                "# Automatically generated by crusty-software do not edit\n"
            )?;
        }

        let alias_lines = {
            let file = File::open(&alias_filename)?;
            let reader = std::io::BufReader::new(file);
            reader.lines().collect::<Result<Vec<String>, _>>()?
        };

        let mut alias_file = OpenOptions::new().append(true).open(alias_filename)?;

        for (_name, package) in self.apt.iter() {
            package.install(options)?;
            Self::write_alias_to_file(&alias_lines, &mut alias_file, package)?;
        }

        for (_name, package) in self.rust.iter() {
            package.install(options)?;
            Self::write_alias_to_file(&alias_lines, &mut alias_file, package)?;
        }

        for (_name, package) in self.flatpak.iter() {
            package.install(options)?;
            Self::write_alias_to_file(&alias_lines, &mut alias_file, package)?;
        }

        for (_name, package) in self.custom.iter() {
            package.install(options)?;
            Self::write_alias_to_file(&alias_lines, &mut alias_file, package)?;
        }

        Ok(())
    }

    fn write_alias_to_file<T: PackageProvider>(
        alias_lines: &[String],
        alias_file: &mut File,
        package: &T,
    ) -> Result<()> {
        for (name, text) in package.get_aliases() {
            let alias_line = format!("alias {}='{}'", name, text);
            if !alias_lines.contains(&alias_line) {
                writeln!(alias_file, "alias {}='{}'", name, text)?
            }
        }
        Ok(())
    }
}
