use crate::flatpak_package::FlatpakPackageList;
use crate::prelude::RustPackageList;
use crate::system_package::SystemPackageList;
use color_eyre::Result;
use indexmap::IndexMap;
use serde::{Deserialize, Serialize};

pub type AliasList = IndexMap<String, String>;

pub trait PackageProvider {}

pub trait PackageListProvider {}

#[derive(Default, Debug, Clone, Eq, PartialEq, Serialize, Deserialize)]
pub struct PackageList {
    pub apt: SystemPackageList,
    pub rust: RustPackageList,
    pub flatpak: FlatpakPackageList,
}

pub struct InstallOptions {
    pub verbose: bool,
}

impl PackageList {
    pub fn serialize(&self) -> Result<String> {
        let toml = toml::to_string(&self)?;
        let header = "# Automatically generated by rust-software. Don't edit manually";
        Ok(format!("{}\n\n{}", header, toml))
    }

    pub fn deserialize(input: &str) -> Result<Self> {
        let mut me: Self = toml::from_str(input)?;
        for (name, package) in me.apt.iter_mut() {
            package.source = name.clone();
        }
        for (name, package) in me.rust.iter_mut() {
            package.source = name.clone();
        }
        for (name, package) in me.flatpak.iter_mut() {
            package.source = name.clone();
        }

        Ok(me)
    }

    pub fn install(&self, options: &InstallOptions) -> Result<()> {
        for (name, package) in self.apt.iter() {
            package.install(&options)?;
        }
        for (name, package) in self.rust.iter() {
            package.install(&options)?;
        }
        for (name, package) in self.flatpak.iter() {
            package.install(&options)?;
        }

        Ok(())
    }
}
