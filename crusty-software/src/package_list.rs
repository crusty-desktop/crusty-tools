use crate::prelude::*;
use crate::utils::get_config;
use crate::APP_NAME;
use ctrem::cprintln;
use serde::{Deserialize, Serialize};
use std::fs::{File, OpenOptions};
use std::io::BufRead;
use std::io::Write;
use std::path::PathBuf;

#[derive(Default, Debug, Clone, Eq, PartialEq, Serialize, Deserialize)]
pub struct PackageList {
    pub apt: SystemPackageList,
    pub rust: RustPackageList,
    pub flatpak: FlatpakPackageList,
    pub custom: CustomPackageList,
}

impl PackageList {
    pub fn serialize(&self) -> color_eyre::Result<String> {
        let toml = toml::to_string(&self)?;
        let header = "# Automatically generated by rust-software. Don't edit manually";
        Ok(format!("{}\n\n{}", header, toml))
    }

    pub fn deserialize(input: &str) -> color_eyre::Result<Self> {
        let mut me: Self = toml::from_str(input)?;
        for (name, package) in me.apt.iter_mut() {
            package.source = name.clone();
        }
        for (name, package) in me.rust.iter_mut() {
            package.source = name.clone();
        }
        for (name, package) in me.flatpak.iter_mut() {
            package.source = name.clone();
        }
        for (name, package) in me.custom.iter_mut() {
            package.source = name.clone();
        }
        Ok(me)
    }

    pub fn install(path: &PathBuf, options: &InstallOptions) -> color_eyre::Result<()> {
        cprintln(&format!(
            "[green]+[/] Installing file [bold][blue]{}[//]",
            path.display()
        ));
        let toml_text = std::fs::read_to_string(path)?;
        let toml_text = format!("{}\n[apt]\n[rust]\n[flatpak]\n[custom]", toml_text);
        match Self::deserialize(&toml_text) {
            Ok(list) => list.install_packages(options)?,
            Err(err) => {
                let inner = err.to_string();
                cprintln(&format!(
                    "    [red]-  Error[/] parsing config file: [green]{}[/]",
                    path.display()
                ));
                eprintln!("{}", inner);
                if !options.keep_running {
                    std::process::exit(1);
                }
            }
        }
        Ok(())
    }

    pub fn install_packages(&self, options: &InstallOptions) -> color_eyre::Result<()> {
        let alias_filename = get_config(APP_NAME, "alias.d")?.join("system.sh");
        if !alias_filename.exists() {
            let mut alias_file = File::create(&alias_filename)?;
            writeln!(alias_file, "#!/usr/bin/env bash")?;
            writeln!(
                alias_file,
                "# Automatically generated by crusty-software do not edit\n"
            )?;
        }

        let alias_lines = {
            let file = File::open(&alias_filename)?;
            let reader = std::io::BufReader::new(file);
            reader
                .lines()
                .collect::<color_eyre::Result<Vec<String>, _>>()?
        };

        let mut alias_file = OpenOptions::new().append(true).open(alias_filename)?;

        for (_name, package) in self.apt.iter() {
            package.install(options)?;
            Self::write_alias_to_file(&alias_lines, &mut alias_file, package)?;
        }

        for (_name, package) in self.rust.iter() {
            package.install(options)?;
            Self::write_alias_to_file(&alias_lines, &mut alias_file, package)?;
        }

        for (_name, package) in self.flatpak.iter() {
            package.install(options)?;
            Self::write_alias_to_file(&alias_lines, &mut alias_file, package)?;
        }

        for (_name, package) in self.custom.iter() {
            package.install(options)?;
            Self::write_alias_to_file(&alias_lines, &mut alias_file, package)?;
        }

        Ok(())
    }

    fn write_alias_to_file<T: PackageProvider>(
        alias_lines: &[String],
        alias_file: &mut File,
        package: &T,
    ) -> color_eyre::Result<()> {
        for (name, text) in package.get_aliases() {
            let alias_line = format!("alias {}='{}'", name, text);
            if !alias_lines.contains(&alias_line) {
                writeln!(alias_file, "alias {}='{}'", name, text)?
            }
        }
        Ok(())
    }
}
